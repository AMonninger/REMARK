'''
This script creates a folder structure that is consistent with the desired 
structure for a repo in the REMARK repository. 

The desired structure of a repo in REMARK is as follows:

./StickyE-REMARK/
    Calibration/        # Directory that contain the necessary code and data to parameterize the model 
    Code/               # The main estimation code, in this case StructuralEstimation.py
    Figures/            # Any figures created by the main code
    Tables/             # Any tables created by the main code
    Equations/          # Any formulas generated or used by the code
    Slides/             # Any slides generated by the code

This script is provided the file paths to those files' current locations and 
pulls them all together into a single location in the desired StickyE format. 

There is a list for each of the sub-folders above that contains the file path 
of all files to be pulled into that location. Any empty list (or "None" value)
indicated that nothing needs to be changed for these files.

A note is also printed out that tells the user where to change the appropriate 
file paths *in* the code above. 
'''
from __future__ import print_function, division
import os
import shutil
from builtins import input
from distutils.dir_util import copy_tree



print("""\nCopy all files from hard-coded sources to destinations to match the
following file structure:

./StickyE-REMARK/
    Calibration/        # Directory that contain the necessary code and data to parameterize the model 
    Code/               # The main estimation code, in this case StructuralEstimation.py
    Figures/            # Any figures created by the main code
    Tables/             # Any tables created by the main code
    Equations/          # Any formulas generated or used by the code
    Slides/             # Any slides generated by the code
""")

print("""\nSet up the source and destination directories for each of the major 
directories listed above. If this would result in overwriting a
file, the script will warn the user, does *not* copy the files, and quits.\n""")


stickyE_code_name_and_current_locations = {'target_module_root_name':"cAndCwithStickyE-REMARK",
                    'current_calibration_location':"Calibration/Parameters/",
                    'current_code_location':"Code/Models/",
                    'current_empirical_location':"Code/Empirical/",
                    'current_figures_location':"Figures/",
                    'current_tables_location':"Tables/",
                    'current_equations_location':"Equations/",
                    'current_slides_location':"Slides/",
                    'current_do_min_file_location':'Code/Models/',
                    'current_do_min_file_name':'StickyE_MAIN.py',
                    'current_do_mid_file_location':'Code/Models/',
                    'current_do_mid_file_name':'StickyE_MAIN.py',
                    'current_do_all_file_location':'Code/Models/',
                    'current_do_all_file_name':'StickyE_MAIN.py',
                    'current_do_all_readme_file_location':'Code/Models/',
                    'current_do_all_readme_file_name':'do_all.txt'}


def remark_ify_code(target_module_root_name,
                    current_calibration_location,
                    current_code_location,
                    current_empirical_location,
                    current_figures_location,
                    current_tables_location,
                    current_equations_location,
                    current_slides_location,
                    current_do_min_file_location,
                    current_do_min_file_name,
                    current_do_mid_file_location,
                    current_do_mid_file_name,
                    current_do_all_file_location,
                    current_do_all_file_name,
                    current_do_all_readme_file_location,
                    current_do_all_readme_file_name):
    # Find the root directory of this REMARK-ify script ...
    # Note: this assumes this script is run from the "root" of the current repo to 
    # copy files around in. 
    my_root_location = os.path.dirname(os.path.realpath(__file__))

    # Construct target module destinations: 
    target_destination_root = os.path.join(my_root_location, target_module_root_name)

    # Construct sources for each directory
    # Note: the following *should* be changed by the users of the code, depending on 
    # where the sources are in the current code base.
    
    # Directories:
    source_calibration_directory    = os.path.join(my_root_location, current_calibration_location)
    source_code_directory           = os.path.join(my_root_location, current_code_location)
    source_empirical_directory      = os.path.join(my_root_location, current_empirical_location)
    source_figures_directory        = os.path.join(my_root_location, current_figures_location)
    source_tables_directory         = os.path.join(my_root_location, current_tables_location)
    source_equations_directory      = os.path.join(my_root_location, current_equations_location)
    source_slides_directory         = os.path.join(my_root_location, current_slides_location)

    # Files:
    source_do_min_file_location     = os.path.join(my_root_location, current_do_min_file_location, current_do_min_file_name)
    source_do_mid_file_location     = os.path.join(my_root_location, current_do_mid_file_location, current_do_mid_file_name)
    source_do_all_file_location     = os.path.join(my_root_location, current_do_all_file_location, current_do_all_file_name)

    source_do_all_readme_file_location  = os.path.join(my_root_location, current_do_all_readme_file_location, current_do_all_readme_file_name)


    # Note: the following should **not** be changed by a user of the script, because 
    # they are dictated by the desired structure of REMARK:
    destination_calibration_directory   = os.path.join(target_destination_root, 'Calibration/')
    destination_code_directory          = os.path.join(target_destination_root, 'Code/')
    destination_empirical_directory     = os.path.join(target_destination_root, 'Empirical/')
    destination_figures_directory       = os.path.join(target_destination_root, 'Figures/')
    destination_tables_directory        = os.path.join(target_destination_root, 'Tables/')
    destination_equations_directory     = os.path.join(target_destination_root, 'Equations/')
    destination_slides_directory        = os.path.join(target_destination_root, 'Slides/')

    # Files:
    destination_do_min_file     = os.path.join(target_destination_root, "do_min.py")
    destination_do_mid_file     = os.path.join(target_destination_root, "do_mid.py")
    destination_do_all_file     = os.path.join(target_destination_root, "do_all.py")

    destination_do_all_readme_file = os.path.join(target_destination_root, "do_all_readme.txt")

    # Set up locations dictionary to copy *from* sources *to* destinations:
    all_dir_locations = {'calibration': {'source':source_calibration_directory, 'destination':destination_calibration_directory},
                         'code':        {'source':source_code_directory, 'destination':destination_code_directory},
                         'empirical':   {'source':source_empirical_directory, 'destination':destination_empirical_directory},
                         'figures':     {'source':source_figures_directory, 'destination':destination_figures_directory},
                         'tables':      {'source':source_tables_directory, 'destination':destination_tables_directory},
                         'equations':   {'source':source_equations_directory, 'destination':destination_equations_directory},
                         'slides':      {'source':source_slides_directory, 'destination':destination_slides_directory} }


    all_file_locations = {'do_min': {'source':source_do_min_file_location, 'destination':destination_do_min_file},
                          'do_mid': {'source':source_do_mid_file_location, 'destination':destination_do_mid_file},
                          'do_all': {'source':source_do_all_file_location, 'destination':destination_do_all_file},
                          'do_all_readme':  {'source':source_do_all_readme_file_location, 'destination':destination_do_all_readme_file} }

    necessary_init_locations = [os.path.join(target_module_root_name, "__init__.py"),
                                os.path.join(destination_code_directory, "__init__.py")]

    # Check to see if destination root directory exists
    # If so, warn and quit
    if os.path.exists(target_destination_root ):
            print("\nThere is already a file or directory at the location "+target_destination_root +". For safety reasons this code does not overwrite existing files.\nPlease remove the file at "+target_destination_root +" and try again.")
            return
    else:
        # create that directory:
        print("\nCreating directory",target_destination_root)
        os.makedirs(target_destination_root)

        # Now copy over all values:
        print("\nNow copying all code components to",target_destination_root,"\nPlease type 'y' or 'Y' to confirm each one.")
        
        for key,val in all_dir_locations.items():
            my_message = """\nYou have indicated you want to copy module:\n    """+ val['source'] + """\nto:\n    """+ val['destination'] +"""\nIs that correct? Please indicate: y / [n]\n\n"""
            user_input = input(my_message)
            if user_input == 'y' or user_input == 'Y':
                #print("copy_tree(",my_directory_full_path,",", target_path,")")
                copy_tree(val['source'], val['destination'])
            else:
                print("Goodbye!")
                return

    # Now loop and move all the files around. 
    # Will need to delete them from current location as well.
    for key,val in all_file_locations.items():
        # Finally, copy the single "do_all" file, which uses a different command,
        # so needs to be executed outside the loop above:
        my_message = """\nYou have indicated you want to copy file:\n    """+ val['source'] + """\nto:\n    """+ val['destination'] +"""\nIs that correct? Please indicate: y / [n]\n\n"""
        user_input = input(my_message)
        if user_input == 'y' or user_input == 'Y':
            #print("copy_tree(",my_directory_full_path,",", target_path,")")
            shutil.copy2(val['source'], val['destination'])
        else:
            print("Goodbye!")
            return

    # Add in __init__.py files in appropriate locations
    for file_location in necessary_init_locations:
        if not os.path.exists(file_location):
            open(file_location, 'a').close()


    print("\nDone creating",target_destination_root)
    print("\n\n````````````````````````````````````````````````````````````````````````````````")
    print("FOUR IMPORTANT FINAL NOTES:\n")
    print("1. You likely need to manually change pathnames in your code in\n")
    print("   ", destination_code_directory)
    print("\n   to correspond to the new directory structure. This cannot be done in this script.")
    print("\n2. Likewise, your 'do_all' files may need to be adjusted to execute the")
    print("   min, mid, and all replication levels. This script cannot change that ")
    print("   and you will need to manually change that to execute whatever is needed.\n")
    print("\n3. You will need to clean up any duplicate files related to do_all.py ")
    print("   and its variations.")
    print("\n4. Finally, you will need to add 'Code._____' to the beginning of import statements")
    print("   code files in Code. You will know this by errors that look like:")
    print("\n       ImportError: No module named SOME_MODULE")
    print("\n   Just add 'Code.SOME_MODULE' to every place you get this error.\n")
    print("Hopefully your code is structured such that this is easy to do.")  
    print("````````````````````````````````````````````````````````````````````````````````")
    return
        
if __name__ == '__main__':
    remark_ify_code(**stickyE_code_name_and_current_locations)


